## Question Ask

Q1: 

a:
首先初始化一个 Count[6] = {0,0,0,0,0,0,0}
然后依次生成
{1,0,0,0,0,0,0}
{1,0,1,0,0,0,0}
{1,0,1,1,0,0,0}
{2,0,1,1,0,0,0}
……………………

其实就比较所有的数，然后可以知道每个数比另外几个数大

b.此算法是稳定的
c.并不是在位的，需要Count数组和最后的S数组



Q2：
- 线性查找，一个个的去找
- 树查询，就是分二叉查找
- Hash查询，通过Hash算法去查询


Q3：
最简单的就是暴力查询

Q4：
a. N/A

b. 不能,至少加一个


Q5：
这需要写代码解决把···TODO 学完图算法之后。


Q6:
a.最优解就是路线最短。
b.设定不同的点，有向图，有些点不联通，联通的才可以走。


Q7：
NA

Q8:
不会，这个涂色问题，的确之前也没做过，留在后面做吧，TODO

[四色定理](https://zh.wikipedia.org/zh-hans/%E5%9B%9B%E8%89%B2%E5%AE%9A%E7%90%86) 不过有这么一个定理的


Q9：
这个22连接起来，从中间做垂线，看是不是有同一个焦点，那就是圆心。


Q10：
见 associate.c